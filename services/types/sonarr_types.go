// Code generated by schema-generate. DO NOT EDIT.

package types

import (
    "errors"
    "bytes"
    "encoding/json"
)

// EpisodeFile 
type EpisodeFile struct {
  Id int `json:"id"`
  Path string `json:"path"`
  Quality string `json:"quality,omitempty"`
  QualityVersion int `json:"qualityVersion,omitempty"`
  RelativePath string `json:"relativePath"`
  ReleaseGroup string `json:"releaseGroup,omitempty"`
  SceneName string `json:"sceneName,omitempty"`
}

// EpisodesArrayItems 
type EpisodesArrayItems struct {
  AirDate string `json:"airDate,omitempty"`
  AirDateUtc string `json:"airDateUtc,omitempty"`
  EpisodeNumber int `json:"episodeNumber"`
  Id int `json:"id"`

  // Deprecated: will be removed in a future version
  Quality string `json:"quality,omitempty"`

  // Deprecated: will be removed in a future version
  QualityVersion int `json:"qualityVersion,omitempty"`

  // Deprecated: will be removed in a future version
  ReleaseGroup string `json:"releaseGroup,omitempty"`

  // Deprecated: will be removed in a future version
  SceneName string `json:"sceneName,omitempty"`
  SeasonNumber int `json:"seasonNumber"`
  Title string `json:"title"`
}

// Release 
type Release struct {
  Indexer string `json:"indexer,omitempty"`
  Quality string `json:"quality,omitempty"`
  QualityVersion int `json:"qualityVersion,omitempty"`
  ReleaseGroup string `json:"releaseGroup,omitempty"`
  ReleaseTitle string `json:"releaseTitle,omitempty"`
  Size int `json:"size,omitempty"`
}

// Series 
type Series struct {
  Id int `json:"id"`
  Path string `json:"path"`
  Title string `json:"title"`
  TvdbId int `json:"tvdbId,omitempty"`
}

// SonarrEvent Sonarr Webhook Event
type SonarrEvent struct {
  EpisodeFile *EpisodeFile `json:"episodeFile,omitempty"`
  Episodes interface{} `json:"episodes,omitempty"`
  EventType interface{} `json:"eventType,omitempty"`
  IsUpgrade bool `json:"isUpgrade,omitempty"`
  Release *Release `json:"release,omitempty"`
  Series *Series `json:"series,omitempty"`
}

func (strct *EpisodeFile) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Path" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "quality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"quality\": ")
	if tmp, err := json.Marshal(strct.Quality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "qualityVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"qualityVersion\": ")
	if tmp, err := json.Marshal(strct.QualityVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RelativePath" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "relativePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"relativePath\": ")
	if tmp, err := json.Marshal(strct.RelativePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "releaseGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"releaseGroup\": ")
	if tmp, err := json.Marshal(strct.ReleaseGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sceneName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sceneName\": ")
	if tmp, err := json.Marshal(strct.SceneName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EpisodeFile) UnmarshalJSON(b []byte) error {
    idReceived := false
    pathReceived := false
    relativePathReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
            pathReceived = true
        case "quality":
            if err := json.Unmarshal([]byte(v), &strct.Quality); err != nil {
                return err
             }
        case "qualityVersion":
            if err := json.Unmarshal([]byte(v), &strct.QualityVersion); err != nil {
                return err
             }
        case "relativePath":
            if err := json.Unmarshal([]byte(v), &strct.RelativePath); err != nil {
                return err
             }
            relativePathReceived = true
        case "releaseGroup":
            if err := json.Unmarshal([]byte(v), &strct.ReleaseGroup); err != nil {
                return err
             }
        case "sceneName":
            if err := json.Unmarshal([]byte(v), &strct.SceneName); err != nil {
                return err
             }
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if path (a required property) was received
    if !pathReceived {
        return errors.New("\"path\" is required but was not present")
    }
    // check if relativePath (a required property) was received
    if !relativePathReceived {
        return errors.New("\"relativePath\" is required but was not present")
    }
    return nil
}

func (strct *EpisodesArrayItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "airDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"airDate\": ")
	if tmp, err := json.Marshal(strct.AirDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "airDateUtc" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"airDateUtc\": ")
	if tmp, err := json.Marshal(strct.AirDateUtc); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "EpisodeNumber" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "episodeNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"episodeNumber\": ")
	if tmp, err := json.Marshal(strct.EpisodeNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "quality" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"quality\": ")
	if tmp, err := json.Marshal(strct.Quality); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "qualityVersion" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"qualityVersion\": ")
	if tmp, err := json.Marshal(strct.QualityVersion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "releaseGroup" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"releaseGroup\": ")
	if tmp, err := json.Marshal(strct.ReleaseGroup); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sceneName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"sceneName\": ")
	if tmp, err := json.Marshal(strct.SceneName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SeasonNumber" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "seasonNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"seasonNumber\": ")
	if tmp, err := json.Marshal(strct.SeasonNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EpisodesArrayItems) UnmarshalJSON(b []byte) error {
    episodeNumberReceived := false
    idReceived := false
    seasonNumberReceived := false
    titleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "airDate":
            if err := json.Unmarshal([]byte(v), &strct.AirDate); err != nil {
                return err
             }
        case "airDateUtc":
            if err := json.Unmarshal([]byte(v), &strct.AirDateUtc); err != nil {
                return err
             }
        case "episodeNumber":
            if err := json.Unmarshal([]byte(v), &strct.EpisodeNumber); err != nil {
                return err
             }
            episodeNumberReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "quality":
            if err := json.Unmarshal([]byte(v), &strct.Quality); err != nil {
                return err
             }
        case "qualityVersion":
            if err := json.Unmarshal([]byte(v), &strct.QualityVersion); err != nil {
                return err
             }
        case "releaseGroup":
            if err := json.Unmarshal([]byte(v), &strct.ReleaseGroup); err != nil {
                return err
             }
        case "sceneName":
            if err := json.Unmarshal([]byte(v), &strct.SceneName); err != nil {
                return err
             }
        case "seasonNumber":
            if err := json.Unmarshal([]byte(v), &strct.SeasonNumber); err != nil {
                return err
             }
            seasonNumberReceived = true
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        }
    }
    // check if episodeNumber (a required property) was received
    if !episodeNumberReceived {
        return errors.New("\"episodeNumber\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if seasonNumber (a required property) was received
    if !seasonNumberReceived {
        return errors.New("\"seasonNumber\" is required but was not present")
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    return nil
}

func (strct *Series) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Path" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "path" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tvdbId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tvdbId\": ")
	if tmp, err := json.Marshal(strct.TvdbId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Series) UnmarshalJSON(b []byte) error {
    idReceived := false
    pathReceived := false
    titleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "path":
            if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
                return err
             }
            pathReceived = true
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        case "tvdbId":
            if err := json.Unmarshal([]byte(v), &strct.TvdbId); err != nil {
                return err
             }
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if path (a required property) was received
    if !pathReceived {
        return errors.New("\"path\" is required but was not present")
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    return nil
}
